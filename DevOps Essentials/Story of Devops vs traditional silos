In this lesson, we will continue our discussion of DevOps culture by telling two stories. The first story will show us how a traditional culture works, and the second story will show us a DevOps culture and how it is different from that traditional culture on a practical level. IT organizations that have both development and operations teams are in the business of shipping code, so both of these stories are going to show how that process works. First, we will discuss the story of some code within the context of a traditional culture or traditional silos. Silos are separated teams, and in the diagram here, you can see that that's represented by the fact that there are walls between the Development team, the QA team, and the Operations team. So let's see what happens to code within a traditional silo structure. First, of course, the developers create some code, and when they're done, they throw it over the wall to QA. At this point the developers are considering themselves to be no longer responsible for it in the sense that they've gone on to work on other things until the QA team bounces the code back to them. Perhaps the QA team found a problem with the code, some bugs, and there's a series of bug fixes, and the code bounces back and forth between Dev and QA until, finally, the QA team says that the code is ready for production. Now that the QA team is finished with the code, they throw it over the wall to Operations, so it's now considered the responsibility of the Operations team. But, oh, no, there's a problem. Something's wrong. The code introduced a bug into production, or it's unable to be deployed for some reason. So what happens? Operations throws it back over the wall to Dev. The problem now is that each group's domain is a black box to the other groups. That means that the developers don't really have much visibility into the production system and Operations has very little visibility into the code. In many situations, when there's a problem, this leads to finger pointing, with both groups claiming that it's not their responsibility. The operations group is saying the system is fine, it's your code that's the problem, and the developers are saying "but the code works on my machine," and they don't know why it's not working in production because they have no visibility into the production system, whereas the Operations team simply assumes that the developers must be the problem. So let's talk about what went wrong in this traditional silo model. First, the development and operations teams are black boxes to each other. That means they have no visibility into each other's domains. This is what leads to finger pointing. Operations is a black box, and so the developers don't really trust them. And in turn, the Operations team doesn't really trust the developers. They both think the problem is caused by the other team. Secondly, the two teams have completely different priorities that pit them against each other and make them enemies. Operations views the developers as breaking stability because they're shipping code, and every once in a while those changes introduce problems into production. On the other hand, developers see Operations as an obstacle to delivering their code. They don't view Operations as being on the same team as them. They view Operations as an obstacle to getting their jobs done. And even if the two teams want to work together, development is measured by delivering features. That means their managers holding them accountable to delivering features, which means deploying and making changes in production. Operations, on the other hand, is measured by up time. Their managers are holding them accountable to stability within the production system. And the changes that are being shipped by the Dev team are bad for stability. And that's why the two teams are fighting against each other. So what are the consequences of all this? We saw that the black boxes lead to finger pointing between the teams. In a traditional silo model, the way of maintaining stability within the system is to have a lengthy process required for deploying code to production. And this lengthy process means a slow time-to-market, a Development team that cannot effectively get their code in front of customers in a quick and efficient manner. Because very few things are automated and there are many manual steps, things like builds and deployments are inconsistent. For example, if deployments are performed manually, the way in which the deployment occurs may depend on which operations engineer happens to be on call when the deployment happens. So different people are going to do things different ways, or even the same person may not do it the same way today that they did yesterday. This inconsistency is a major source of problems in production. And because neither team has visibility into the other team's domain and they're spending a lot of time finger pointing, it takes longer than it needs to to identify and fix problems. So we can see that ultimately, the traditional silo model is bad for both speed of delivery and stability, because the developers have this lengthy process that they have to go through in order to try and maintain stability. And yet, when problems do happen, it's more difficult than it needs to be to resolve those problems. But let's look at what happens to code within a DevOps culture. This story starts out the same way as the story of traditional silos. It begins with developers writing some code. When the developer commits their code, this initiates a series of automated steps, automated builds, automated integration, automated testing, and eventually, automated deployment. Because all these steps are automated, the QAs can get their hands on the code almost immediately after the developers write it, which means they can be testing constantly while developers are writing their code. Once the code is ready to be deployed to production, an automated deployment is kicked off, and the code gets to production in a consistent and stable manner. Now what's important to understand about a DevOps culture is this series of automated steps and this series of tools that enables this process requires collaboration between all of these teams. They all have to be onboard. They all have to buy into this process and contribute to creating this process in order for it to work. Because all these steps are automated, it is much easier to deploy code in a stable fashion, and therefore deployments can occur much more frequently, potentially multiple times a day, meaning that we're getting features and bug fixes into the hands of customers much more quickly. But wait, the latest deployment broke something. What happens in a DevOps environment when the developers do deploy some bad code, something is broken in production. One of the most important aspects of all this automation that goes with DevOps is monitoring. And so in this scenario, some automated monitoring detected the problem almost immediately and notified the team that there was an issue. The team is then able to use the same automated system that they were able to use to do the deployment in the first place to rollback. They're able to deploy a previous working version of the code very, very quickly, so the problem is fixed immediately. Now usually a rollback might be considered bad for the development team, but not in a DevOps environment. We did a rollback, but an hour later, the Dev team is able to deploy a fixed version of the new code containing the new features that they were trying to deploy when they broke something. So we had immediate recovery from the problem that was introduced and very quickly we were able to roll out a fix. So we have speed of delivery and stability even when there's a problem. And in many cases the problem can even be fixed before customers really know about it. So what went right in this story? Development and Operations worked together to build a robust automated process for changing code quickly and reliably, and they were able to do this because they came together to prioritize both speed of delivery and stability. Automation led to consistency. Every stage of the process, from building to testing to deployment, it  happened the same way every time. And because it was automated, it could happen much more quickly and much more often. Robust monitoring plus the swift automated deployment process, ensured that problems could be fixed even before users noticed them. Development and Operations worked together up front to build these good robust processes. And even though a code change caused a problem, the users actually experienced little or no downtime. Let's talk for just a moment about why you should do DevOps, and these are just a few of the reasons. DevOps usually results in happier teams. Tech employees tend to be happier doing DevOps than they are under a traditional silo structure. Because things are automated and more stable, they can spend more time innovating and less time putting out fires, and technical people and engineers love to innovate. Developers don't feel like they are constantly having to fight to get their work out in front of customers, and Operations people don't have to fight Dev to keep the system stable, so this leads to much happier engineering teams. But it also leads to a happier customers, and, of course, that's the most important thing for the success of an IT organization. DevOps lets us give customers the features that they want much more quickly than a traditional model, and we don't have to sacrifice stability to do it. So I hope that these two stories have helped you to understand DevOps culture and how it is different from a culture of traditional silos. In the next section of this course, we're going to start discussing some of the practices and concepts that support this DevOps culture.